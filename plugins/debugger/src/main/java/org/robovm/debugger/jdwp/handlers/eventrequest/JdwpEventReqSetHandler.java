/*
 * Copyright 2016 Justin Shapcott.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.robovm.debugger.jdwp.handlers.eventrequest;

import org.robovm.debugger.DebuggerException;
import org.robovm.debugger.jdwp.handlers.eventrequest.events.IJdwpEventDelegate;
import org.robovm.debugger.jdwp.handlers.eventrequest.events.predicates.EventClassNameMatchPredicate;
import org.robovm.debugger.jdwp.handlers.eventrequest.events.predicates.EventClassTypeIdPredicate;
import org.robovm.debugger.jdwp.handlers.eventrequest.events.predicates.EventExceptionPredicate;
import org.robovm.debugger.jdwp.handlers.eventrequest.events.predicates.EventInstanceIdPredicate;
import org.robovm.debugger.jdwp.handlers.eventrequest.events.predicates.EventLocationPredicate;
import org.robovm.debugger.jdwp.handlers.eventrequest.events.predicates.EventModCountPredicate;
import org.robovm.debugger.jdwp.handlers.eventrequest.events.predicates.EventPredicate;
import org.robovm.debugger.jdwp.handlers.eventrequest.events.predicates.EventStepModPredicate;
import org.robovm.debugger.jdwp.handlers.eventrequest.events.predicates.EventThreadRefIdPredicate;
import org.robovm.debugger.jdwp.JdwpConsts;
import org.robovm.debugger.jdwp.protocol.IJdwpRequestHandler;
import org.robovm.debugger.utils.bytebuffer.DataBufferReader;
import org.robovm.debugger.utils.bytebuffer.DataBufferWriter;

import java.util.ArrayList;
import java.util.List;

/**
 * @author Demyan Kimitsa
 *         Set an event request. When the event described by this request occurs, an event is sent from the target VM.
 *         If an event occurs that has not been requested then it is not sent from the target VM. The two exceptions to this
 *         are the VM Start Event and the VM Death Event which are automatically generated events
 */
public class JdwpEventReqSetHandler implements IJdwpRequestHandler {

    private final IJdwpEventDelegate center;

    public JdwpEventReqSetHandler(IJdwpEventDelegate center) {
        this.center = center;
    }

    @Override
    public short handle(DataBufferReader payload, DataBufferWriter output) {
        // parse input
        byte eventKind = payload.readByte();
        byte suspendPolicy = payload.readByte();
        List<EventPredicate> eventPredicates = new ArrayList<>();

        int modifierCount = payload.readInt32();
        try {
            for (int i = 0; i < modifierCount; i++) {
                byte modKind = payload.readByte();
                switch (modKind) {
                    case JdwpConsts.EventModifier.CASE_COUNT:
                        // Case Count - if modKind is 1
                        // Limit the requested event to be reported at most once after a given number of occurrences. The event
                        // is not reported the first count - 1 times this filter is reached. To request a one-off event,
                        // call this method with a count of 1.

                        int caseCount = payload.readInt32();
                        eventPredicates.add(new EventModCountPredicate(modKind, caseCount));
                        break;

                    case JdwpConsts.EventModifier.CONDITIONAL:
                        // Case Conditional - if modKind is 2
                        // Conditional on expression, For the future
                        // ignoring
                        int exprID = payload.readInt32();
                        break;

                    case JdwpConsts.EventModifier.THREAD_ONLY:
                        // Case ThreadOnly - if modKind is 3
                        // Restricts reported events to those in the given thread. This modifier can be used with any event kind
                        // except for class unload.
                        if (eventKind == JdwpConsts.EventKind.CLASS_UNLOAD)
                            throw new DebuggerException(JdwpConsts.Error.INVALID_EVENT_TYPE);
                        long threadID = payload.readLong();
                        eventPredicates.add(new EventThreadRefIdPredicate(modKind, threadID));
                        break;

                    case JdwpConsts.EventModifier.CLASS_ONLY:
                        // Case ClassOnly - if modKind is 4
                        // For class prepare events, restricts the events generated by this request to be the preparation of the
                        // given reference type and any subtypes.
                        long refTypeId = payload.readLong();
                        eventPredicates.add(new EventClassTypeIdPredicate(modKind, refTypeId));
                        break;

                    case JdwpConsts.EventModifier.CLASS_MATCH:
                        // Case ClassMatch - if modKind is 5
                        // Restricts reported events to those for classes whose name matches the given restricted regular expression.
                        // Required class pattern. Matches are limited to exact matches of the given class pattern and matches of
                        // patterns that begin or end with '*'; for example, "*.Foo" or "java.*".
                        String machPattern = payload.readStringWithLen();
                        eventPredicates.add(new EventClassNameMatchPredicate(modKind, machPattern, false));
                        break;

                    case JdwpConsts.EventModifier.CLASS_EXCLUDE:
                        // Case ClassExclude - if modKind is 6
                        // Restricts reported events to those for classes whose name does not match the given restricted regular
                        // expression
                        String excludePattern = payload.readStringWithLen();
                        eventPredicates.add(new EventClassNameMatchPredicate(modKind, excludePattern, true));
                        break;

                    case JdwpConsts.EventModifier.LOCATION_ONLY:
                        // Case LocationOnly - if modKind is 7
                        // Restricts reported events to those that occur at the given location. This modifier can be used with
                        // breakpoint, field access, field modification, step, and exception event kinds.
                        if (eventKind != JdwpConsts.EventKind.SINGLE_STEP && eventKind != JdwpConsts.EventKind.BREAKPOINT &&
                                eventKind != JdwpConsts.EventKind.EXCEPTION) {
                            throw new DebuggerException(JdwpConsts.Error.INVALID_LOCATION);
                        }

                        byte tag = payload.readByte();
                        long classID = payload.readLong();
                        long methodID = payload.readLong();
                        long index = payload.readLong();
                        eventPredicates.add(new EventLocationPredicate(modKind, tag, classID, methodID, index));
                        break;

                    case JdwpConsts.EventModifier.EXCEPTION_ONLY:
                        // Case ExceptionOnly - if modKind is 8
                        // Restricts reported exceptions by their class and whether they are caught or uncaught. This modifier
                        // can be used with exception event kinds only.
                        if (eventKind != JdwpConsts.EventKind.EXCEPTION)
                            throw new DebuggerException(JdwpConsts.Error.INVALID_EVENT_TYPE);

                        // Exception to report. Null (0) means report exceptions of all types. A non-null type restricts the reported
                        // exception events to exceptions of the given type or any of its subtypes.
                        long exceptionRefTypeID = payload.readLong();
                        boolean caught = payload.readBoolean(); // Report caught exceptions
                        boolean uncaught = payload.readBoolean(); // Report uncaught exceptions.
                        eventPredicates.add(new EventExceptionPredicate(modKind, exceptionRefTypeID, caught, uncaught));
                        break;

                    case JdwpConsts.EventModifier.FIELD_ONLY:
                        // Case FieldOnly - if modKind is 9
                        long referenceTypeID = payload.readLong();
                        long fieldID = payload.readLong();
                        // TODO: don't think RoboVM can handle this, skipping for now
                        break;

                    case JdwpConsts.EventModifier.STEP:
                        // Case Step - if modKind is 10
                        // Restricts reported step events to those which satisfy depth and size constraints. This modifier can
                        // be used with step event kinds only.
                        if (eventKind != JdwpConsts.EventKind.SINGLE_STEP)
                            throw new DebuggerException(JdwpConsts.Error.INVALID_EVENT_TYPE);
                        long stepThreadID = payload.readLong();
                        int stepSize = payload.readInt32();
                        int stepDepth = payload.readInt32();
                        eventPredicates.add(new EventStepModPredicate(modKind, stepThreadID, stepSize, stepDepth));
                        break;

                    case JdwpConsts.EventModifier.INSTANCE_ONLY:
                        // Case InstanceOnly - if modKind is 11
                        // Restricts reported events to those whose active 'this' object is the given object. Match value is the
                        // null object for static methods.
                        long instanceId = payload.readLong();
                        eventPredicates.add(new EventInstanceIdPredicate(modKind, instanceId));
                        break;

                    default:
                        throw new DebuggerException("unsupported modifier kind " + modKind, JdwpConsts.Error.NOT_IMPLEMENTED);
                }

            }

            // parsed all data, register event
            int requestId = center.jdwpSetEventRequest(eventKind, suspendPolicy, eventPredicates);
            output.writeInt32(requestId);

            return JdwpConsts.Error.NONE;
        } catch (DebuggerException e) {
            if (e.getCode() != -1)
                return (short) e.getCode();
            throw e;
        }
    }

    @Override
    public byte getCommandSet() {
        return 15;
    }

    @Override
    public byte getCommand() {
        return 1;
    }

    @Override
    public String toString() {
        return "EventRequest(15).Set(1)";
    }
}
